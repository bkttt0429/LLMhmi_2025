<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ©Ÿå™¨æ‰‹è‡‚ 3D èª¿è©¦å·¥å…·</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            color: #fff;
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            max-width: 350px;
            font-size: 12px;
            z-index: 100;
            max-height: 90vh;
            overflow-y: auto;
        }

        #info h3 {
            color: #00ff88;
            margin-bottom: 10px;
        }

        #info pre {
            background: #1a1a1a;
            padding: 8px;
            border-radius: 4px;
            overflow-x: auto;
            font-size: 10px;
            margin: 5px 0;
            color: #00d4ff;
        }

        .status {
            margin: 5px 0;
            padding: 5px;
            background: rgba(0, 255, 136, 0.1);
            border-left: 3px solid #00ff88;
        }

        .error {
            background: rgba(255, 68, 68, 0.1);
            border-left: 3px solid #ff4444;
        }

        .warning {
            background: rgba(255, 170, 0, 0.1);
            border-left: 3px solid #ffaa00;
        }

        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
        }

        button {
            background: #00ff88;
            color: #000;
            border: none;
            padding: 8px 15px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        button:hover {
            background: #00d4ff;
        }

        input[type="file"] {
            margin: 5px 0;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 50;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top: 4px solid #00ff88;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .loading-text {
            margin-top: 20px;
            color: #00ff88;
        }

        .controls-title {
            margin-bottom: 10px;
            color: #00ff88;
        }
    </style>
</head>

<body>
    <div id="container"></div>

    <div id="loading">
        <div class="spinner"></div>
        <p class="loading-text">æ­£åœ¨è¼‰å…¥æ¨¡å‹...</p>
    </div>

    <div id="info">
        <h3>ğŸ” æ¨¡å‹è¨ºæ–·è³‡è¨Š</h3>
        <div id="log"></div>
    </div>

    <div id="controls">
        <h4 class="controls-title">æ¨¡å‹æ§åˆ¶</h4>
        <input type="file" id="fileInput" accept=".glb,.gltf" aria-label="ä¸Šå‚³æ¨¡å‹æ–‡ä»¶" />
        <br>
        <button onclick="toggleWireframe()">åˆ‡æ›ç·šæ¡†æ¨¡å¼</button>
        <button onclick="toggleAxes()">åˆ‡æ›åº§æ¨™è»¸</button>
        <button onclick="resetCamera()">é‡è¨­ç›¸æ©Ÿ</button>
        <button onclick="dumpModelInfo()">é¡¯ç¤ºå®Œæ•´çµæ§‹</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // === Setup ===
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);

        const camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(5, 5, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        document.getElementById('container').appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // === Lighting ===
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(5, 10, 5);
        dirLight.castShadow = true;
        scene.add(dirLight);

        const fillLight = new THREE.DirectionalLight(0x4488ff, 0.5);
        fillLight.position.set(-5, 5, -5);
        scene.add(fillLight);

        // === Grid ===
        const gridHelper = new THREE.GridHelper(10, 10, 0x00ff88, 0x444444);
        scene.add(gridHelper);

        const axesHelper = new THREE.AxesHelper(5);
        scene.add(axesHelper);
        window.axesHelper = axesHelper;

        // === Logging ===
        function log(msg, type = 'status') {
            const logDiv = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = type;
            entry.innerHTML = `<small>${new Date().toLocaleTimeString()}</small> ${msg}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(msg);
        }

        // === Model Loading ===
        let loadedModel = null;
        let wireframeMode = false;
        const loader = new GLTFLoader();

        function loadModel(url) {
            log(`ğŸ“‚ è¼‰å…¥æ¨¡å‹: ${url}`, 'status');
            document.getElementById('loading').style.display = 'block';

            loader.load(
                url,
                (gltf) => {
                    document.getElementById('loading').style.display = 'none';
                    log('âœ… æ¨¡å‹è¼‰å…¥æˆåŠŸ', 'status');

                    if (loadedModel) {
                        scene.remove(loadedModel);
                    }

                    loadedModel = gltf.scene;
                    scene.add(loadedModel);

                    // åˆ†ææ¨¡å‹çµæ§‹
                    analyzeModel(loadedModel);

                    // è‡ªå‹•ç½®ä¸­æ¨¡å‹ (Auto-Center)
                    const box = new THREE.Box3().setFromObject(loadedModel);
                    const center = box.getCenter(new THREE.Vector3());

                    // ä¿®æ­£ä½ç½®ï¼šä¸­å¿ƒé»å°é½Š X/Z (0,0)ï¼Œåº•éƒ¨å°é½Š Y (0)
                    loadedModel.position.x -= center.x;
                    loadedModel.position.z -= center.z;
                    loadedModel.position.y -= box.min.y;

                    log(`ğŸ¯ åŸ·è¡Œè‡ªå‹•ç½®ä¸­: ä¿®æ­£åç§» (${center.x.toFixed(3)}, ${box.min.y.toFixed(3)}, ${center.z.toFixed(3)})`, 'status');

                    // è‡ªå‹•èª¿æ•´ç›¸æ©Ÿ
                    fitCameraToModel(loadedModel);

                    // å•Ÿç”¨é™°å½±
                    loadedModel.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                },
                (progress) => {
                    const percent = (progress.loaded / progress.total * 100).toFixed(0);
                    log(`â³ è¼‰å…¥é€²åº¦: ${percent}%`, 'status');
                },
                (error) => {
                    document.getElementById('loading').style.display = 'none';
                    log(`âŒ è¼‰å…¥å¤±æ•—: ${error.message}`, 'error');
                    console.error(error);
                }
            );
        }

        function analyzeModel(model) {
            log('<br><strong>ğŸ”¬ æ¨¡å‹çµæ§‹åˆ†æ:</strong>', 'status');

            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());

            log(`ğŸ“ å°ºå¯¸: ${size.x.toFixed(2)} x ${size.y.toFixed(2)} x ${size.z.toFixed(2)}`, 'status');
            log(`ğŸ“ ä¸­å¿ƒ: (${center.x.toFixed(2)}, ${center.y.toFixed(2)}, ${center.z.toFixed(2)})`, 'status');

            let meshCount = 0;
            let nodeCount = 0;
            const nodeNames = [];

            model.traverse((child) => {
                nodeCount++;
                if (child.name) {
                    nodeNames.push(child.name);
                }
                if (child.isMesh) {
                    meshCount++;
                    log(`ğŸ”· Mesh: "${child.name}" | æè³ª: ${child.material.type} | ä¸‰è§’å½¢: ${child.geometry.index ? child.geometry.index.count / 3 : 'N/A'}`, 'status');
                }
            });

            log(`ğŸ“Š ç¯€é»æ•¸: ${nodeCount} | Meshæ•¸: ${meshCount}`, 'status');
            log('<strong>ğŸ·ï¸ æ‰€æœ‰ç¯€é»åç¨±:</strong>', 'status');
            log(`<pre>${nodeNames.join('\n')}</pre>`, 'status');

            // æª¢æŸ¥å¯èƒ½çš„é—œç¯€åç¨±
            const possibleJoints = nodeNames.filter(name =>
                name.toLowerCase().includes('base') ||
                name.toLowerCase().includes('shoulder') ||
                name.toLowerCase().includes('elbow') ||
                name.toLowerCase().includes('joint') ||
                name.toLowerCase().includes('arm')
            );

            if (possibleJoints.length > 0) {
                log(`ğŸ¯ å¯èƒ½çš„é—œç¯€: ${possibleJoints.join(', ')}`, 'status');
            } else {
                log('âš ï¸ æœªæ‰¾åˆ°æ˜é¡¯çš„é—œç¯€åç¨±', 'warning');
            }
        }

        function fitCameraToModel(model) {
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());

            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
            cameraZ *= 2.5; // ç•™é»ç©ºé–“

            camera.position.set(center.x + cameraZ, center.y + cameraZ / 2, center.z + cameraZ);
            camera.lookAt(center);
            controls.target.copy(center);
            controls.update();

            log(`ğŸ“· ç›¸æ©Ÿå·²èª¿æ•´è‡³æœ€ä½³ä½ç½®`, 'status');
        }

        // === Controls ===
        window.toggleWireframe = function () {
            wireframeMode = !wireframeMode;
            if (loadedModel) {
                loadedModel.traverse((child) => {
                    if (child.isMesh) {
                        child.material.wireframe = wireframeMode;
                    }
                });
                log(`ğŸ”² ç·šæ¡†æ¨¡å¼: ${wireframeMode ? 'é–‹å•Ÿ' : 'é—œé–‰'}`, 'status');
            }
        };

        window.toggleAxes = function () {
            axesHelper.visible = !axesHelper.visible;
            log(`ğŸ“ åº§æ¨™è»¸: ${axesHelper.visible ? 'é¡¯ç¤º' : 'éš±è—'}`, 'status');
        };

        window.resetCamera = function () {
            if (loadedModel) {
                fitCameraToModel(loadedModel);
            } else {
                camera.position.set(5, 5, 5);
                camera.lookAt(0, 0, 0);
            }
        };

        window.dumpModelInfo = function () {
            if (!loadedModel) {
                log('âŒ æ²’æœ‰è¼‰å…¥çš„æ¨¡å‹', 'error');
                return;
            }

            log('<br><strong>ğŸ“‹ å®Œæ•´æ¨¡å‹æ¨¹ç‹€çµæ§‹:</strong>', 'status');
            let output = '';
            loadedModel.traverse((child) => {
                const indent = '  '.repeat(getDepth(child));
                const type = child.type;
                const name = child.name || '(ç„¡åç¨±)';
                output += `${indent}â””â”€ [${type}] ${name}\n`;

                if (child.isMesh) {
                    output += `${indent}   â”œâ”€ æè³ª: ${child.material.name || child.material.type}\n`;
                    output += `${indent}   â””â”€ å¹¾ä½•: ${child.geometry.type}\n`;
                }
            });
            log(`<pre>${output}</pre>`, 'status');
        };

        function getDepth(node) {
            let depth = 0;
            let current = node;
            while (current.parent) {
                depth++;
                current = current.parent;
            }
            return depth;
        }

        // === File Input ===
        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const url = URL.createObjectURL(file);
                loadModel(url);
            }
        });

        // === Animation ===
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // === Resize ===
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // === Auto-load default model ===
        const defaultModelPath = './models/eezybotarm.glb';
        log('ğŸš€ å•Ÿå‹•è¨ºæ–·å·¥å…·', 'status');
        log(`å˜—è©¦è¼‰å…¥é è¨­æ¨¡å‹: ${defaultModelPath}`, 'status');
        loadModel(defaultModelPath);

        // === Export for debugging ===
        window.scene = scene;
        window.camera = camera;
        window.loadedModel = () => loadedModel;
    </script>
</body>

</html>