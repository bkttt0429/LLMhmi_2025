<!DOCTYPE html>
<!-- VERSION: 2025-12-07-FIX-SENDCMD-v2 - CRITICAL UPDATE -->
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Force browser to reload JS/CSS (no cache) -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>TACTICAL COMMAND v15.0 [DUAL-LINK]</title>

    <!-- Local Tailwind CSS (compiled) -->
    <link rel="stylesheet" href="/static/css/output.css">

    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
</head>

<body
    class="h-screen flex flex-col p-2 sm:p-4 gap-4 bg-[url('https://www.transparenttextures.com/patterns/dark-matter.png')]">

    <header
        class="flex flex-col sm:flex-row justify-between items-start sm:items-end border-b border-green-500/30 pb-2 shrink-0 gap-2">
        <div>
            <h1
                class="text-2xl sm:text-3xl lg:text-4xl font-bold tracking-widest text-green-400 drop-shadow-[0_0_5px_rgba(0,255,157,0.8)]">
                SHIM INTERFACE <span class="text-xs sm:text-sm text-gray-500">v15.0 DUAL-LINK</span></h1>
            <div class="text-[10px] sm:text-xs text-gray-400 tracking-wider flex items-center gap-4 flex-wrap">
                <div class="flex items-center gap-1">
                    <span>CONTROL(UDP):</span>
                    <span id="car-ip-display" class="text-yellow-500 font-bold">--.--.--.--</span>
                </div>
                <div class="flex items-center gap-1">
                    <span>VIDEO:</span>
                    <span id="cam-ip-display" class="text-blue-400 font-bold">--.--.--.--</span>
                </div>
                <span id="gamepad-status" class="opacity-30 transition-opacity flex items-center gap-1">üéÆ
                    GAMEPAD</span>
            </div>
        </div>
        <div id="clock" class="text-lg sm:text-2xl text-green-600">00:00:00</div>
    </header>

    <div id="main-view" class="flex-1 grid grid-cols-1 lg:grid-cols-12 gap-4 min-h-0 pb-20">

        <div class="lg:col-span-8 flex flex-col gap-2 relative cyber-border rounded p-1 min-h-[300px]">
            <div class="flex justify-between px-2 text-[10px] sm:text-xs text-gray-500 font-bold flex-wrap gap-2">
                <div class="flex gap-2 items-center text-green-600">
                    SYSTEM STATUS: <span class="text-green-400">OPERATIONAL</span>
                </div>
                <span>FEED: <span class="text-green-400 animate-pulse">LIVE</span></span>
            </div>

            <div
                class="flex-1 bg-black relative overflow-hidden flex items-center justify-center border border-gray-800 group">
                <div class="scan-line"></div>
                <img src="/video_feed" alt="Live video feed from ESP32-S3 camera" class="w-full h-full object-contain"
                    onerror="this.style.display='none'; document.getElementById('no-sig').style.display='flex'">

                <div id="no-sig" class="hidden absolute inset-0 flex-col items-center justify-center bg-black/80 z-20">
                    <div
                        class="text-2xl sm:text-4xl text-red-500 font-bold border-4 border-red-500 p-4 sm:p-6 animate-pulse">
                        NO SIGNAL</div>
                    <div class="text-red-400 mt-2 text-xs sm:text-sm">CHECK ESP32-S3 (CAMERA)</div>
                </div>

                <div class="absolute inset-0 flex items-center justify-center pointer-events-none opacity-30">
                    <div class="w-[40px] h-[40px] border border-green-500 rounded-full absolute"></div>
                    <div class="w-[200px] h-[1px] bg-green-500"></div>
                    <div class="h-[200px] w-[1px] bg-green-500 absolute"></div>
                </div>
            </div>

            <div id="log-box"
                class="h-24 sm:h-32 bg-black border-t border-gray-700 p-2 font-mono text-[10px] sm:text-xs overflow-y-auto text-gray-400 leading-tight">
                <div class="text-green-700">> Initializing Dual-Link Interface...</div>
            </div>
        </div>

        <div class="lg:col-span-4 flex flex-col gap-4">

            <div class="cyber-border p-2 sm:p-4 flex flex-col items-center justify-center relative grow-0">
                <div class="absolute top-2 left-2 text-[10px] text-gray-500 tracking-widest">SONAR (ESP12F)</div>

                <div
                    class="relative w-32 h-32 sm:w-40 sm:h-40 lg:w-56 lg:h-56 rounded-full border border-green-900 bg-black/80 shadow-[inset_0_0_20px_rgba(0,50,0,0.5)]">
                    <canvas id="radar-canvas-main" class="absolute inset-0 w-full h-full rounded-full"></canvas>
                </div>

                <div id="dist-val"
                    class="text-xl sm:text-2xl lg:text-3xl font-bold mt-2 text-green-400 drop-shadow-[0_0_5px_rgba(0,255,0,0.5)]">
                    --.-- CM</div>
            </div>

            <div class="cyber-border p-3 sm:p-6 flex-1 flex flex-col justify-center gap-4 sm:gap-6 relative">
                <div class="absolute top-2 left-2 text-[10px] text-gray-500 tracking-widest">MANUAL OVERRIDE</div>

                <div class="grid grid-cols-3 gap-2 sm:gap-3 w-full max-w-[180px] sm:max-w-[240px] mx-auto">
                    <div></div>
                    <button class="btn-cy h-10 sm:h-12 lg:h-14 rounded text-base sm:text-lg lg:text-xl"
                        onmousedown="sendCmd('F')" onmouseup="sendCmd('S')" ontouchstart="sendCmd('F')"
                        ontouchend="sendCmd('S')" id="btn-w">W</button>
                    <div></div>

                    <button class="btn-cy h-10 sm:h-12 lg:h-14 rounded text-base sm:text-lg lg:text-xl"
                        onmousedown="sendCmd('L')" onmouseup="sendCmd('S')" ontouchstart="sendCmd('L')"
                        ontouchend="sendCmd('S')" id="btn-a">A</button>
                    <button class="btn-cy h-10 sm:h-12 lg:h-14 rounded text-base sm:text-lg lg:text-xl"
                        onmousedown="sendCmd('S')" ontouchstart="sendCmd('S')" id="btn-s">S</button>
                    <button class="btn-cy h-10 sm:h-12 lg:h-14 rounded text-base sm:text-lg lg:text-xl"
                        onmousedown="sendCmd('R')" onmouseup="sendCmd('S')" ontouchstart="sendCmd('R')"
                        ontouchend="sendCmd('S')" id="btn-d">D</button>

                    <div></div>
                    <button class="btn-cy h-10 sm:h-12 lg:h-14 rounded text-base sm:text-lg lg:text-xl"
                        onmousedown="sendCmd('B')" onmouseup="sendCmd('S')" ontouchstart="sendCmd('B')"
                        ontouchend="sendCmd('S')" id="btn-x">X</button>
                    <div></div>
                </div>

                <!-- Speed Limiter Slider -->
                <div class="speed-limiter-container">
                    <div class="flex justify-between items-center mb-2">
                        <span class="text-[10px] text-gray-400 uppercase tracking-wider">Speed Limit</span>
                        <span class="speed-value" id="speed-limit-value">100%</span>
                    </div>
                    <input type="range" min="0" max="100" value="100" step="5" class="speed-slider"
                        id="speed-limit-slider" title="Control speed limit" aria-label="Speed limit slider">
                </div>

                <button class="btn-cy w-full py-2 sm:py-3 rounded tracking-widest text-xs sm:text-sm"
                    onclick="toggleLight()">TOGGLE LIGHTS (ESP32 CAM)</button>
            </div>

            <div class="xbox-card rounded p-3 sm:p-4 flex flex-col gap-3 relative">
                <div class="absolute top-2 left-2 text-[10px] text-gray-500 tracking-widest">XBOX TELEMETRY</div>
                <div class="flex items-center gap-4">
                    <!-- Enhanced Xbox Stick Visual -->
                    <div class="relative flex flex-col items-center gap-2">
                        <div class="relative xbox-stick" id="xbox-stick"></div>
                        <div class="text-[9px] text-gray-500 font-mono" id="stick-coords">X:0.00 Y:0.00</div>
                    </div>

                    <div class="flex flex-col gap-2 flex-1">
                        <!-- Button Indicators -->
                        <div class="flex gap-2">
                            <div
                                class="flex items-center gap-1 px-2 py-1 rounded border border-gray-700 bg-black/40 text-[10px]">
                                <span class="text-green-400 font-bold">A</span>
                                <div class="w-2 h-2 rounded-full bg-gray-700" id="btn-indicator-a"></div>
                            </div>
                            <div
                                class="flex items-center gap-1 px-2 py-1 rounded border border-gray-700 bg-black/40 text-[10px]">
                                <span class="text-blue-400 font-bold">X</span>
                                <div class="w-2 h-2 rounded-full bg-gray-700" id="btn-indicator-x"></div>
                            </div>
                            <div
                                class="flex items-center gap-1 px-2 py-1 rounded border border-gray-700 bg-black/40 text-[10px]">
                                <span class="text-purple-400 font-bold">LS</span>
                                <div class="w-2 h-2 rounded-full bg-gray-700" id="btn-indicator-ls"></div>
                            </div>
                        </div>

                        <!-- Control Info -->
                        <div class="space-y-1 text-[10px] text-gray-400">
                            <div class="flex items-center gap-2"><span class="text-green-400 font-mono">LS</span>ÔºöÁßªÂãïÊéßÂà∂
                            </div>
                            <div class="flex items-center gap-2"><span class="text-blue-400 font-mono">X</span>ÔºöÁ∑äÊÄ•ÁÖûËªä
                            </div>
                            <div class="flex items-center gap-2"><span class="text-green-400 font-mono">A</span>ÔºöË£úÂÖâÁáà
                            </div>
                        </div>
                    </div>
                </div>

                <!-- PWM Output Display -->
                <div class="grid grid-cols-2 gap-2 text-[10px] font-mono">
                    <div class="bg-black/60 border border-green-900/50 rounded p-1.5">
                        <div class="text-gray-500">LEFT PWM</div>
                        <div class="text-green-400 font-bold text-sm" id="pwm-left">0</div>
                    </div>
                    <div class="bg-black/60 border border-green-900/50 rounded p-1.5">
                        <div class="text-gray-500">RIGHT PWM</div>
                        <div class="text-green-400 font-bold text-sm" id="pwm-right">0</div>
                    </div>
                </div>

                <div class="flex items-center justify-between text-[10px] sm:text-xs text-gray-400">
                    <div>CMD: <span id="xbox-cmd" class="text-yellow-400 font-mono">--</span></div>
                    <div id="ai-status" class="text-gray-500">AI: STANDBY</div>
                </div>
            </div>

        </div>
    </div>

    <!-- Settings View -->
    <div id="settings-view" class="flex-1 overflow-auto p-2 sm:p-4 pb-20 view-hidden">
        <div class="max-w-3xl mx-auto space-y-4">

            <div class="cyber-border rounded p-3 sm:p-4 bg-black/60">
                <div class="text-green-400 font-bold mb-3 flex items-center gap-2 text-sm sm:text-base">
                    <span class="text-xl">üì°</span> DUAL-LINK CONNECTION
                </div>
                <div class="space-y-4">
                    <div class="p-3 border border-green-900/50 rounded bg-green-900/10">
                        <label class="block text-xs text-green-400 mb-1 font-bold">üöó Car Control IP (ESP12F)</label>
                        <div class="text-[10px] text-gray-500 mb-2">Êé•Êî∂ UDP Êåá‰ª§ÁöÑÈÅôÊéßËªä (Port 4210)</div>
                        <input id="settings-car-ip" type="text"
                            class="w-full bg-black text-green-400 border border-green-900 px-2 py-2 rounded focus:outline-none focus:border-green-500 text-sm font-mono"
                            placeholder="192.168.x.x">
                    </div>

                    <div class="p-3 border border-blue-900/50 rounded bg-blue-900/10">
                        <label class="block text-xs text-blue-400 mb-1 font-bold">üìπ Camera Stream IP (ESP32-S3)</label>
                        <div class="text-[10px] text-gray-500 mb-2">Êèê‰æõÂΩ±ÂÉè‰∏≤ÊµÅ (Port 81)</div>
                        <input id="settings-cam-ip" type="text"
                            class="w-full bg-black text-blue-400 border border-blue-900 px-2 py-2 rounded focus:outline-none focus:border-blue-500 text-sm font-mono"
                            placeholder="192.168.x.x">
                    </div>

                    <button onclick="applySettings()" class="btn-cy w-full py-3 rounded text-sm font-bold">APPLY DUAL IP
                        SETTINGS</button>
                </div>
            </div>

            <!-- SYSTEM TOOLS (AI Model Selection) -->
            <div class="cyber-border rounded p-3 sm:p-4 bg-black/60">
                <div class="text-green-400 font-bold mb-3 text-sm sm:text-base">SYSTEM TOOLS</div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div class="flex flex-col gap-2">
                        <button onclick="toggleAI()" id="ai-toggle-btn"
                            class="btn-cy py-2 rounded text-xs sm:text-sm">ACTIVATE AI HUD</button>
                        <button onclick="exportLogs()" class="btn-cy py-2 rounded text-xs sm:text-sm">EXPORT SYSTEM
                            LOGS</button>
                        <button onclick="showNetInfo()"
                            class="btn-cy py-2 rounded text-xs sm:text-sm text-blue-300 border-blue-500">SHOW NET
                            INFO</button>
                    </div>

                    <!-- AI Model Selector -->
                    <div class="flex flex-col gap-2 p-2 border border-green-900/30 rounded">
                        <label class="text-xs text-green-400 font-bold">üß† AI Model Selection</label>
                        <div class="flex gap-2">
                            <select id="model-selector" title="Select AI model for object detection"
                                class="bg-black text-green-400 border border-green-800 rounded px-2 py-1 text-xs flex-1">
                                <option value="yolov13l.pt" selected>YOLOv13-Large (Default)</option>
                                <option value="yolov8n.pt">YOLOv8-Nano (Fast)</option>
                                <option value="yolov8s.pt">YOLOv8-Small</option>
                                <option value="yolov8m.pt">YOLOv8-Medium</option>
                            </select>
                            <button onclick="applyModel()" class="btn-cy px-4 text-xs rounded font-bold">LOAD</button>
                        </div>
                        <div class="text-[9px] text-gray-500">
                            * Use Nano/Small for CPU. Large requires NVIDIA GPU.
                        </div>
                    </div>
                </div>
            </div>

            <div class="cyber-border rounded p-3 sm:p-4 bg-black/60">
                <div class="text-green-400 font-bold mb-3 text-sm sm:text-base">CAMERA CONFIGURATION</div>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 text-xs">

                    <!-- Selectors -->
                    <div class="flex flex-col gap-1">
                        <label class="text-gray-400">Resolution</label>
                        <select id="cfg-framesize" title="Camera resolution setting"
                            onchange="updateCameraSetting('framesize', this.value)"
                            class="bg-black border border-green-900 text-green-400 p-1 rounded">
                            <option value="11">VGA (640x480)</option>
                            <option value="10">HVGA (480x320)</option>
                            <option value="9">CIF (400x296)</option>
                            <option value="8">QVGA (320x240)</option>
                            <option value="6">HQVGA (240x176)</option>
                            <option value="5">QCIF (176x144)</option>
                        </select>
                    </div>

                    <div class="flex flex-col gap-1">
                        <label class="text-gray-400">Special Effect</label>
                        <select id="cfg-special_effect" title="Camera special effect filter"
                            onchange="updateCameraSetting('special_effect', this.value)"
                            class="bg-black border border-green-900 text-green-400 p-1 rounded">
                            <option value="0">No Effect</option>
                            <option value="1">Negative</option>
                            <option value="2">Grayscale</option>
                            <option value="3">Red Tint</option>
                            <option value="4">Green Tint</option>
                            <option value="5">Blue Tint</option>
                            <option value="6">Sepia</option>
                        </select>
                    </div>

                    <div class="flex flex-col gap-1">
                        <label class="text-gray-400">WB Mode</label>
                        <select id="cfg-wb_mode" title="Camera white balance mode"
                            onchange="updateCameraSetting('wb_mode', this.value)"
                            class="bg-black border border-green-900 text-green-400 p-1 rounded">
                            <option value="0">Auto</option>
                            <option value="1">Sunny</option>
                            <option value="2">Cloudy</option>
                            <option value="3">Office</option>
                            <option value="4">Home</option>
                        </select>
                    </div>

                    <!-- Sliders -->
                    <div class="col-span-full grid grid-cols-1 sm:grid-cols-2 gap-4 border-t border-gray-800 pt-2">
                        <div class="flex flex-col gap-1">
                            <div class="flex justify-between"><label>Quality (10-63)</label><span id="val-quality"
                                    class="text-gray-500">--</span></div>
                            <input type="range" id="cfg-quality" min="10" max="63" step="1"
                                title="Camera image quality (10-63)" aria-label="Quality slider from 10 to 63"
                                onchange="updateCameraSetting('quality', this.value)" class="accent-green-500">
                        </div>
                        <div class="flex flex-col gap-1">
                            <div class="flex justify-between"><label>Brightness (-2 to 2)</label><span
                                    id="val-brightness" class="text-gray-500">--</span></div>
                            <input type="range" id="cfg-brightness" min="-2" max="2" step="1"
                                title="Camera brightness adjustment (-2 to 2)"
                                aria-label="Brightness slider from -2 to 2"
                                onchange="updateCameraSetting('brightness', this.value)" class="accent-green-500">
                        </div>
                        <div class="flex flex-col gap-1">
                            <div class="flex justify-between"><label>Contrast (-2 to 2)</label><span id="val-contrast"
                                    class="text-gray-500">--</span></div>
                            <input type="range" id="cfg-contrast" min="-2" max="2" step="1"
                                title="Camera contrast adjustment (-2 to 2)" aria-label="Contrast slider from -2 to 2"
                                onchange="updateCameraSetting('contrast', this.value)" class="accent-green-500">
                        </div>
                        <div class="flex flex-col gap-1">
                            <div class="flex justify-between"><label>Saturation (-2 to 2)</label><span
                                    id="val-saturation" class="text-gray-500">--</span></div>
                            <input type="range" id="cfg-saturation" min="-2" max="2" step="1"
                                title="Camera saturation adjustment (-2 to 2)"
                                aria-label="Saturation slider from -2 to 2"
                                onchange="updateCameraSetting('saturation', this.value)" class="accent-green-500">
                        </div>
                    </div>

                    <!-- Toggles -->
                    <div
                        class="col-span-full grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-2 border-t border-gray-800 pt-2">
                        <button id="btn-awb" onclick="toggleCamBool('awb')"
                            class="btn-cy py-1 text-[10px] rounded">AWB</button>
                        <button id="btn-aec" onclick="toggleCamBool('aec')" class="btn-cy py-1 text-[10px] rounded">AEC
                            (Sensor)</button>
                        <button id="btn-aec2" onclick="toggleCamBool('aec2')"
                            class="btn-cy py-1 text-[10px] rounded">AEC (DSP)</button>
                        <button id="btn-agc" onclick="toggleCamBool('agc')"
                            class="btn-cy py-1 text-[10px] rounded">AGC</button>
                        <button id="btn-bpc" onclick="toggleCamBool('bpc')"
                            class="btn-cy py-1 text-[10px] rounded">BPC</button>
                        <button id="btn-wpc" onclick="toggleCamBool('wpc')"
                            class="btn-cy py-1 text-[10px] rounded">WPC</button>
                        <button id="btn-raw_gma" onclick="toggleCamBool('raw_gma')"
                            class="btn-cy py-1 text-[10px] rounded">Raw GMA</button>
                        <button id="btn-lenc" onclick="toggleCamBool('lenc')"
                            class="btn-cy py-1 text-[10px] rounded">Lens Corr</button>
                        <button id="btn-hmirror" onclick="toggleCamBool('hmirror')"
                            class="btn-cy py-1 text-[10px] rounded">H-Mirror</button>
                        <button id="btn-vflip" onclick="toggleCamBool('vflip')"
                            class="btn-cy py-1 text-[10px] rounded">V-Flip</button>
                        <button id="btn-dcw" onclick="toggleCamBool('dcw')"
                            class="btn-cy py-1 text-[10px] rounded">DCW</button>
                        <button id="btn-colorbar" onclick="toggleCamBool('colorbar')"
                            class="btn-cy py-1 text-[10px] rounded">Colorbar</button>
                    </div>

                </div>
            </div>

        </div>
    </div>

    <div class="nav-bar">
        <button onclick="switchView('main')" class="nav-btn active" id="nav-main">
            <span>üéÆ</span> <span class="hidden sm:inline">COMMAND</span>
        </button>
        <button onclick="switchView('settings')" class="nav-btn" id="nav-settings">
            <span>‚öô</span> <span class="hidden sm:inline">SYSTEM</span>
        </button>
    </div>

    <script>
        // === Global State ===
        let currentView = 'main';
        let socket;
        let wsConnected = false;
        let lastLogs = [];

        // Canvas State
        const radarBlips = [];
        let radarAngle = 0;
        let lastFrameTime = 0;
        let controllerLinked = false;
        let lastXboxUpdate = 0;
        let lastKeyboardActivity = 0;  // Track keyboard input for priority

        // Keyboard state tracking
        let keyPressed = {};

        // === Speed Limiter System ===
        let speedLimitPercent = 100; // Global speed limit (0-100%)

        function applySpeedLimit(pwmValue) {
            return Math.round(pwmValue * (speedLimitPercent / 100));
        }

        function updateSpeedLimitDisplay() {
            const display = document.getElementById('speed-limit-value');
            if (display) display.innerText = speedLimitPercent + '%';
        }

        window.onload = () => {
            initWebSocket();
            resizeCanvas();
            requestAnimationFrame(animationLoop);
            log("System Initialized. Dual-Link Mode Active.");
            fetchModels();

            // Add keyboard event listeners
            setupKeyboardControls();

            // Initialize speed limiter
            initSpeedLimiter();
        };

        // === Speed Limiter Initialization ===
        function initSpeedLimiter() {
            const slider = document.getElementById('speed-limit-slider');
            if (!slider) {
                console.warn('[SPEED_LIMITER] Slider element not found');
                return;
            }

            // Set initial value
            speedLimitPercent = parseInt(slider.value);
            updateSpeedLimitDisplay();

            // Bind input event
            slider.addEventListener('input', (e) => {
                speedLimitPercent = parseInt(e.target.value);
                updateSpeedLimitDisplay();
                console.log(`[SPEED_LIMITER] Updated to ${speedLimitPercent}%`);
            });

            // Bind change event for final value (when user releases slider)
            slider.addEventListener('change', (e) => {
                log(`Speed Limit set to ${speedLimitPercent}%`);
            });

            console.log('[SPEED_LIMITER] Initialized successfully');
        }


        function setupKeyboardControls() {
            // Track which keys are currently pressed
            document.addEventListener('keydown', (e) => {
                const key = e.key.toUpperCase();

                // Prevent repeated keydown events when holding
                if (keyPressed[key]) return;
                keyPressed[key] = true;

                // Update keyboard activity timestamp for input priority
                lastKeyboardActivity = Date.now();

                console.log(`[KEYBOARD] Key DOWN: ${key}`);

                // Map keys to commands
                switch (key) {
                    case 'W':
                        sendCmd('F');
                        break;
                    case 'S':
                        sendCmd('S');
                        break;
                    case 'A':
                        sendCmd('L');
                        break;
                    case 'D':
                        sendCmd('R');
                        break;
                    case 'X':
                        sendCmd('B');
                        break;
                }
            });

            document.addEventListener('keyup', (e) => {
                const key = e.key.toUpperCase();
                keyPressed[key] = false;

                console.log(`[KEYBOARD] Key UP: ${key}`);

                // Send stop command when key released
                if (['W', 'A', 'S', 'D', 'X'].includes(key)) {
                    sendCmd('S');
                }
            });

            console.log('[KEYBOARD] Event listeners installed');
        }

        async function fetchModels() {
            try {
                const res = await fetch('/api/get_models');
                const data = await res.json();
                const selector = document.getElementById('model-selector');
                if (data.models && data.models.length > 0) {
                    selector.innerHTML = ''; // Clear defaults
                    data.models.forEach(model => {
                        const opt = document.createElement('option');
                        opt.value = model;
                        opt.text = model;
                        selector.appendChild(opt);
                    });
                }
            } catch (e) {
                console.log("Failed to fetch models", e);
            }
        }

        async function applyModel() {
            const model = document.getElementById('model-selector').value;
            if (!model) return;
            log(`Switching AI model to ${model}...`);
            try {
                const res = await fetch('/api/set_model', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ model: model })
                });
                const data = await res.json();
                if (data.status === 'ok') {
                    log(`Model switched to ${model}`);
                } else {
                    log(`Failed to switch model: ${data.msg}`);
                }
            } catch (e) {
                log(`Error switching model: ${e}`);
            }
        }

        window.addEventListener('resize', resizeCanvas);

        function resizeCanvas() {
            const mainC = document.getElementById('radar-canvas-main');
            if (mainC) {
                mainC.width = mainC.parentElement.clientWidth;
                mainC.height = mainC.parentElement.clientHeight;
            }
        }

        function initWebSocket() {
            socket = io({ transports: ['websocket'] });
            socket.on('connect', () => { wsConnected = true; log("WS Connected"); });
            socket.on('disconnect', () => { wsConnected = false; log("WS Disconnected"); });

            // Handle status updates pushed from server (replaces polling)
            socket.on('status_update', (data) => {
                updateUI(data);
            });

            socket.on('controller_data', (data) => {
                controllerLinked = true;
                lastXboxUpdate = Date.now();
                updateXboxVisual(data.left_stick_x || 0, data.left_stick_y || 0, data.stick_pressed || false);
                if (data.cmd) {
                    document.getElementById('xbox-cmd').innerText = data.cmd;
                    highlightKey(data.cmd);
                }
                const icon = document.getElementById('gamepad-status');
                if (icon) {
                    icon.classList.remove('gamepad-inactive');
                    icon.classList.add('gamepad-active');
                }
            });
        }

        function updateUI(data) {
            // Êõ¥Êñ∞ header ÁöÑ IP È°ØÁ§∫
            const carIpDisplay = document.getElementById('car-ip-display');
            const camIpDisplay = document.getElementById('cam-ip-display');

            if (data.car_ip) {
                carIpDisplay.innerText = data.car_ip;
                carIpDisplay.className = "text-green-400 font-bold font-mono";
                // ÂêåÊ≠•Êõ¥Êñ∞ Settings Ê¨Ñ‰Ωç
                const setCar = document.getElementById('settings-car-ip');
                if (setCar && !setCar.value) setCar.value = data.car_ip;
            }

            if (data.camera_ip) {
                camIpDisplay.innerText = data.camera_ip;
                camIpDisplay.className = "text-blue-400 font-bold font-mono";
                // ÂêåÊ≠•Êõ¥Êñ∞ Settings Ê¨Ñ‰Ωç
                const setCam = document.getElementById('settings-cam-ip');
                if (setCam && !setCam.value) setCam.value = data.camera_ip;
            }

            // Êõ¥Êñ∞ AI ÁãÄÊÖã
            const aiStatus = document.getElementById('ai-status');
            if (data.ai_status) {
                aiStatus.innerText = "AI: ACTIVE";
                aiStatus.className = "text-green-400 font-bold animate-pulse";
                document.getElementById('ai-toggle-btn').innerText = "DEACTIVATE AI";
            } else {
                aiStatus.innerText = "AI: STANDBY";
                aiStatus.className = "text-gray-500";
                document.getElementById('ai-toggle-btn').innerText = "ACTIVATE AI HUD";
            }

            // Êõ¥Êñ∞Ë∑ùÈõ¢
            const distVal = document.getElementById('dist-val');
            if (data.dist !== undefined) {
                distVal.innerText = data.dist.toFixed(2) + " CM";
            }

            // Logs
            if (data.logs) {
                const serialized = JSON.stringify(data.logs);
                if (serialized !== JSON.stringify(lastLogs)) {
                    lastLogs = data.logs.slice();
                    const box = document.getElementById('log-box');
                    box.innerHTML = "";
                    data.logs.forEach(l => {
                        const d = document.createElement('div');
                        d.innerText = l;
                        box.appendChild(d);
                    });
                    box.scrollTop = box.scrollHeight;
                }
            }
        }

        function applySettings() {
            const carIp = document.getElementById('settings-car-ip').value;
            const camIp = document.getElementById('settings-cam-ip').value;

            // ÂàÜÂà•ÁôºÈÄÅË®≠ÂÆö
            if (carIp) {
                fetch('/api/set_ip', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ car_ip: carIp })
                });
            }
            if (camIp) {
                fetch('/api/set_ip', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ cam_ip: camIp })
                });
            }
            log(`Settings applied. CAR:${carIp}, CAM:${camIp}`);
            switchView('main');
        }

        // === Animation & Visuals ===
        function animationLoop(timestamp) {
            const dt = timestamp - lastFrameTime;
            lastFrameTime = timestamp;
            drawRadar(document.getElementById('radar-canvas-main'), timestamp);

            // Gamepad heartbeat check
            if (Date.now() - lastXboxUpdate > 2000) {
                const icon = document.getElementById('gamepad-status');
                if (icon) {
                    icon.classList.remove('gamepad-active');
                    icon.classList.add('gamepad-inactive');
                }
            }

            updateJoystickLoop();
            requestAnimationFrame(animationLoop);
        }

        // === Xbox Controller Logic ===
        let lastGamepadCmdTime = 0;
        let wasJoystickActive = false;
        const CMD_INTERVAL = 50; // Throttle to 20Hz

        function updateJoystickLoop() {
            // Get Gamepads (Standard Mapping)
            // Index 0 is usually the first connected controller
            const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
            const gp = gamepads[0]; // Focus on the first controller

            if (!gp || !gp.connected) return;

            // Mark as active
            const icon = document.getElementById('gamepad-status');
            if (icon) {
                icon.classList.remove('gamepad-inactive');
                icon.classList.add('gamepad-active');
            }
            lastXboxUpdate = Date.now();


            // === 1. Read Inputs ===
            // Standard Gamepad Mapping:
            // Axes[0] = Left Stick X (-1 Left, +1 Right)
            // Axes[1] = Left Stick Y (-1 Up, +1 Down)
            let rawX = gp.axes[0];
            let rawY = gp.axes[1];

            // [DEBUG] Log raw stick values
            if (Math.abs(rawX) > 0.15 || Math.abs(rawY) > 0.15) {
                console.log(`[GAMEPAD] üïπÔ∏è STICK RAW ‚Üí axisX:${rawX.toFixed(2)}, axisY:${rawY.toFixed(2)}`);
            }

            // === 1.1 Input Priority Check ===
            // If keyboard was used recently (within 500ms), suppress gamepad
            if (Date.now() - lastKeyboardActivity < 500) {
                // If gamepad was active, we might need to send a stop? 
                // But keyboard handles its own stop when keyup.
                // Just return to avoid conflict.
                return;
            }

            // === 2. Deadzone Processing ===
            const DEADZONE = 0.15;
            const applyDeadzone = (val) => Math.abs(val) < DEADZONE ? 0 : val;

            let steer = applyDeadzone(rawX);     // -1.0 (Left) to 1.0 (Right)
            let throttle = -applyDeadzone(rawY); // Invert Y: Up is positive

            // === 3. Update Visuals ===
            // Update stick animation and button indicators
            updateXboxVisual(rawX, rawY, gp.buttons[10] && gp.buttons[10].pressed);

            // Update button indicators
            updateButtonIndicator('a', gp.buttons[0] && gp.buttons[0].pressed);
            updateButtonIndicator('x', gp.buttons[2] && gp.buttons[2].pressed);
            updateButtonIndicator('ls', gp.buttons[10] && gp.buttons[10].pressed);

            // === 4. Differential Drive Mixing ===
            // Formula:
            //   Left  = Throttle + Steer
            //   Right = Throttle - Steer
            // When turning right (steer > 0): Left speeds up, Right slows down
            let leftVal = throttle + steer;
            let rightVal = throttle - steer;

            if (Math.abs(leftVal) > 0.1 || Math.abs(rightVal) > 0.1) {
                console.log(`[GAMEPAD] ‚öôÔ∏è MIXED ‚Üí L:${leftVal.toFixed(2)}, R:${rightVal.toFixed(2)}`);
            }

            // Clamp and scale
            leftVal = Math.max(-1, Math.min(1, leftVal));
            rightVal = Math.max(-1, Math.min(1, rightVal));

            const MAX_PWM = 255;
            let leftPWM = Math.round(leftVal * MAX_PWM);
            let rightPWM = Math.round(rightVal * MAX_PWM);

            // Apply speed limiter to gamepad as well
            leftPWM = applySpeedLimit(leftPWM);
            rightPWM = applySpeedLimit(rightPWM);

            // Update PWM display in real-time
            updatePWMDisplay(leftPWM, rightPWM);

            if (leftPWM !== 0 || rightPWM !== 0) {
                console.log(`[GAMEPAD] üì§ PWM ‚Üí L:${leftPWM}, R:${rightPWM}`);
            }


            // === 5. Throttling & Sending ===
            // Only send if time interval passed OR immediate stop
            // [FIX] Input Priority: Only send if joystick is active OR just became inactive
            const isStickActive = (leftPWM !== 0 || rightPWM !== 0);

            if (!isStickActive && !wasJoystickActive) {
                // Joystick is idle and was already idle. Do NOT send anything.
                // This allows Keyboard (WASD) commands to pass through.
                return;
            }

            const now = Date.now();
            if (isStickActive || (now - lastGamepadCmdTime > CMD_INTERVAL) || !wsConnected) { // wsConnected check is dummy here, mainly logic below

                // Allow sending if: 
                // 1. Stick is moving (Active)
                // 2. Stick JUST stopped (wasActive=true, isActive=false) - Send ONE (0,0)
                // 3. Throttle condition met

                if (isStickActive || wasJoystickActive) {
                    if ((now - lastGamepadCmdTime > CMD_INTERVAL) || (wasJoystickActive && !isStickActive)) {


                        // Construct payload
                        const payload = { left: leftPWM, right: rightPWM };

                        // Visual Debug
                        document.getElementById('xbox-cmd').innerText = `L:${leftPWM} R:${rightPWM}`;

                        // Send 
                        fetch('/api/control', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        }).catch(e => { /* Ignore fetch errors */ });

                        lastGamepadCmdTime = now;
                    }
                }
            }

            wasJoystickActive = isStickActive;

            // Button Bindings for Lights (A Button = Index 0)
            if (gp.buttons[0] && gp.buttons[0].pressed) {
                // Debounce could be added here, but toggleLight handles state
                // For simple press-and-hold or toggle
            }
        }

        function drawRadar(canvas, time) {
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const w = canvas.width, h = canvas.height;
            const cx = w / 2, cy = h / 2, radius = Math.min(w, h) / 2 - 2;

            ctx.clearRect(0, 0, w, h);

            // Grid
            ctx.strokeStyle = 'rgba(0, 255, 157, 0.2)';
            ctx.lineWidth = 1;
            ctx.beginPath(); ctx.arc(cx, cy, radius, 0, Math.PI * 2); ctx.stroke();
            ctx.beginPath(); ctx.arc(cx, cy, radius * 0.5, 0, Math.PI * 2); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(cx, cy - radius); ctx.lineTo(cx, cy + radius); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(cx - radius, cy); ctx.lineTo(cx + radius, cy); ctx.stroke();

            // Sweep
            radarAngle = (time / 2000 * Math.PI * 2) % (Math.PI * 2);
            const grad = ctx.createConicGradient(radarAngle - Math.PI / 2, cx, cy);
            grad.addColorStop(0, 'rgba(0, 255, 157, 0)');
            grad.addColorStop(0.8, 'rgba(0, 255, 157, 0.1)');
            grad.addColorStop(1, 'rgba(0, 255, 157, 0.4)');
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(cx, cy, radius, 0, Math.PI * 2); ctx.fill();
        }

        function sendCmd(cmd) {
            console.log(`[KEYBOARD] sendCmd called with: ${cmd}`);
            highlightKey(cmd);

            // [Input Priority] Update keyboard activity timestamp
            lastKeyboardActivity = Date.now();

            // Map commands to differential drive PWM (-255 to 255)
            let left = 0, right = 0;

            switch (cmd) {
                case 'F': // Forward (reduced from 200 to 130)
                    left = 130; right = 130;
                    break;
                case 'B': // Backward (reduced from -200 to -130)
                    left = -130; right = -130;
                    break;
                case 'L': // Turn Left (reduced from ¬±150 to ¬±100)
                    left = -100; right = 100;
                    break;
                case 'R': // Turn Right (reduced from ¬±150 to ¬±100)
                    left = 100; right = -100;
                    break;
                case 'S': // Stop
                    left = 0; right = 0;
                    break;
                default:
                    console.log(`[KEYBOARD] Unknown command: ${cmd}`);
                    return; // Ignore unknown commands
            }

            // Apply speed limiter
            left = applySpeedLimit(left);
            right = applySpeedLimit(right);

            console.log(`[KEYBOARD] Sending: L=${left}, R=${right}`);

            // Send through your backend API
            fetch('/api/control', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ left: left, right: right })
            })
                .then(response => {
                    if (!response.ok) {
                        return response.text().then(text => {
                            console.error(`[KEYBOARD] Backend error ${response.status}:`, text);
                            throw new Error(`HTTP ${response.status}: ${text}`);
                        });
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('[KEYBOARD] Command sent successfully:', data);
                })
                .catch(e => console.error('[KEYBOARD] Control error:', e));
        }

        function highlightKey(cmd) {
            const map = { 'F': 'btn-w', 'L': 'btn-a', 'S': 'btn-s', 'R': 'btn-d', 'B': 'btn-x' };
            const id = map[cmd];
            if (id) {
                const btn = document.getElementById(id);
                btn.classList.add('btn-active');
                setTimeout(() => btn.classList.remove('btn-active'), 150);
            }
        }

        function updateXboxVisual(x, y, pressed) {
            const stick = document.getElementById('xbox-stick');
            const coords = document.getElementById('stick-coords');
            if (!stick) return;

            const clamp = (v) => Math.max(-1, Math.min(1, v));
            const offset = 24; // Increased offset for more visible movement
            const dx = clamp(x) * offset;
            const dy = clamp(y) * offset; // Keep Y as-is for visual representation

            // Note: transform needs to stay as inline style for dynamic positioning
            stick.style.transform = `translate(${dx}px, ${dy}px)`;

            // Enhanced visual feedback with CSS classes
            if (pressed) {
                stick.classList.add('xbox-stick-pressed');
                stick.classList.remove('xbox-stick-normal');
                stick.style.transform = `translate(${dx}px, ${dy}px) scale(0.9)`;
            } else {
                stick.classList.remove('xbox-stick-pressed');
                stick.classList.add('xbox-stick-normal');
            }

            // Update coordinates display
            if (coords) {
                coords.innerText = `X:${x.toFixed(2)} Y:${y.toFixed(2)}`;
            }
        }

        function updateButtonIndicator(buttonId, pressed) {
            const indicator = document.getElementById(`btn-indicator-${buttonId}`);
            if (!indicator) return;

            if (pressed) {
                indicator.classList.remove('bg-gray-700');
                indicator.classList.add('bg-green-400');
                indicator.classList.add('indicator-active');
                indicator.classList.remove('indicator-inactive');
            } else {
                indicator.classList.remove('bg-green-400');
                indicator.classList.add('bg-gray-700');
                indicator.classList.remove('indicator-active');
                indicator.classList.add('indicator-inactive');
            }
        }

        function updatePWMDisplay(left, right) {
            const leftEl = document.getElementById('pwm-left');
            const rightEl = document.getElementById('pwm-right');

            if (leftEl) {
                leftEl.innerText = left;
                // Color coding based on direction
                if (left > 0) leftEl.className = 'text-green-400 font-bold text-sm';
                else if (left < 0) leftEl.className = 'text-red-400 font-bold text-sm';
                else leftEl.className = 'text-gray-500 font-bold text-sm';
            }

            if (rightEl) {
                rightEl.innerText = right;
                if (right > 0) rightEl.className = 'text-green-400 font-bold text-sm';
                else if (right < 0) rightEl.className = 'text-red-400 font-bold text-sm';
                else rightEl.className = 'text-gray-500 font-bold text-sm';
            }
        }

        let lightState = false;
        function toggleLight() {
            lightState = !lightState;
            sendCmd(lightState ? 'W' : 'w');
        }

        function toggleAI() {
            fetch('/api/toggle_ai', { method: 'POST' });
        }

        function exportLogs() {
            const logs = document.getElementById('log-box').innerText;
            const blob = new Blob([logs], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = 'system_logs.txt'; a.click();
        }

        async function showNetInfo() {
            try {
                const res = await fetch('/netinfo');
                const data = await res.json();
                let msg = "=== NETWORK INTERFACES ===\n\n";

                if (data.camera_net) {
                    msg += `[CAMERA NET] (ESP32)\nName: ${data.camera_net.name}\nIP: ${data.camera_net.ip}\nMAC: ${data.camera_net.mac}\n\n`;
                } else {
                    msg += `[CAMERA NET] Not Detected\n\n`;
                }

                if (data.internet_net) {
                    msg += `[INTERNET/CAR NET]\nName: ${data.internet_net.name}\nIP: ${data.internet_net.ip}\nMAC: ${data.internet_net.mac}\n\n`;
                } else {
                    msg += `[INTERNET/CAR NET] Not Detected\n\n`;
                }

                msg += "--- Other Interfaces ---\n";
                data.all_ifaces.forEach(iface => {
                    if ((!data.camera_net || iface.name !== data.camera_net.name) &&
                        (!data.internet_net || iface.name !== data.internet_net.name)) {
                        msg += `${iface.name}: ${iface.ip}\n`;
                    }
                });

                alert(msg);
                log("Network Info retrieved.");
            } catch (e) {
                alert("Failed to fetch network info");
            }
        }

        // === Camera Config ===
        const camState = {};

        async function fetchCameraSettings() {
            try {
                const res = await fetch('/api/camera_settings');
                if (!res.ok) return;
                const data = await res.json();

                // Update UI elements
                const updateVal = (id, val) => {
                    const el = document.getElementById(id);
                    if (el) {
                        el.value = val;
                        // Trigger onchange manually if needed, or just update UI
                        const display = document.getElementById('val-' + id.replace('cfg-', ''));
                        if (display) display.innerText = val;
                    }
                };

                // Selects & Sliders
                ['framesize', 'special_effect', 'wb_mode', 'quality', 'brightness', 'contrast', 'saturation'].forEach(key => {
                    if (data[key] !== undefined) {
                        updateVal('cfg-' + key, data[key]);
                        camState[key] = data[key];
                    }
                });

                // Toggles
                ['awb', 'aec', 'aec2', 'agc', 'bpc', 'wpc', 'raw_gma', 'lenc', 'hmirror', 'vflip', 'dcw', 'colorbar'].forEach(key => {
                    if (data[key] !== undefined) {
                        camState[key] = data[key];
                        const btn = document.getElementById('btn-' + key);
                        if (btn) {
                            if (data[key] == 1) btn.classList.add('btn-active');
                            else btn.classList.remove('btn-active');
                        }
                    }
                });

                log("Camera settings synced.");

            } catch (e) {
                log("Failed to sync camera settings.");
            }
        }

        async function updateCameraSetting(varName, val) {
            // Update local state and UI display immediately
            camState[varName] = val;
            const display = document.getElementById('val-' + varName);
            if (display) display.innerText = val;

            try {
                await fetch('/api/camera_settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ var: varName, val: Number(val) })
                });
            } catch (e) {
                log(`Failed to set ${varName}`);
            }
        }

        function toggleCamBool(varName) {
            const current = camState[varName] || 0;
            const newVal = current ? 0 : 1;

            // Toggle visual state
            const btn = document.getElementById('btn-' + varName);
            if (btn) {
                if (newVal) btn.classList.add('btn-active');
                else btn.classList.remove('btn-active');
            }

            updateCameraSetting(varName, newVal);
        }

        function switchView(view) {
            currentView = view;
            const mainView = document.getElementById('main-view');
            const settingsView = document.getElementById('settings-view');

            // Toggle view visibility with CSS classes
            if (view === 'main') {
                mainView.classList.remove('view-hidden');
                mainView.classList.add('view-grid');
                settingsView.classList.add('view-hidden');
                settingsView.classList.remove('view-block');
            } else {
                mainView.classList.add('view-hidden');
                mainView.classList.remove('view-grid');
                settingsView.classList.remove('view-hidden');
                settingsView.classList.add('view-block');
            }

            document.querySelectorAll('.nav-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById('nav-' + view).classList.add('active');

            if (view === 'settings') {
                fetchCameraSettings();
            }
        }

        function log(msg) {
            const box = document.getElementById('log-box');
            if (box) {
                const time = new Date().toLocaleTimeString('en-GB');
                const d = document.createElement('div');
                d.innerHTML = `<span class="text-gray-600">[${time}]</span> ${msg}`;
                box.appendChild(d);
                box.scrollTop = box.scrollHeight;
            }
        }

        // Keyboard
        document.addEventListener('keydown', (e) => {
            if (e.repeat) return;
            const k = e.key.toUpperCase();
            const map = {
                'W': 'F', 'A': 'L', 'S': 'S', 'D': 'R', 'X': 'B', ' ': 'S',
                'Q': 'Q', 'E': 'E', 'Z': 'Z', 'C': 'C'
            };
            if (map[k]) sendCmd(map[k]);
        });
        document.addEventListener('keyup', (e) => {
            if (['W', 'A', 'D', 'X', 'Q', 'E', 'Z', 'C'].includes(e.key.toUpperCase())) sendCmd('S');
        });

        setInterval(() => {
            document.getElementById('clock').innerText = new Date().toLocaleTimeString();
        }, 1000);
    </script>
</body>

</html>