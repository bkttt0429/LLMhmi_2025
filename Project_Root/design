-│
-├── Firmware/ (ESP32 Arduino 代碼)
-│   ├── esp32_main.ino         # 主程式 (setup, loop)
-│   ├── camera_config.h        # 相機腳位定義與初始化設定
-│   ├── network.h              # WiFi 與 WebServer 處理
-│   └── ultrasonic.h           # [未來加入] 超聲波測距邏輯
-│
-└── PC_Client/ (Python 電腦端代碼)
-    ├── main.py                # 程式入口 (啟動 GUI)
-    ├── gui.py                 # 介面佈局 (按鈕、視窗設定)
-    ├── video_thread.py        # 負責抓取串流影像 (QThread)
-    ├── serial_worker.py       # 負責 Serial 通訊
-    ├── ai_detector.py         # [未來加入] YOLO/物體檢測邏輯
-    └── config.py              # 全域參數 (解析度、URL、Port)
\ No newline at end of file
+# 系統架構與資料流程圖
+
+本設計文件整理 ESP32-S3 CAM（超聲波整合）與 Python/Flask 前後端的互動流程，方便後續重新設計 UI 或擴充功能。
+
+## 元件概覽
+- **ESP32-S3 CAM 韌體**：
+  - 透過 `esp32_main.ino` 啟動相機、Wi-Fi、WebServer 與超聲波量測，每 500 ms 以序列埠輸出 `DIST:<value>` 及警告訊息。
+- **Python 後端 (PC_Client)**：
+  - `web_server.py` 啟動 Flask + Socket.IO，負責接收串流、轉發指令、推送日誌。
+  - `serial_worker.py` 持續掃描序列埠，取得 ESP32 IP 與距離數據，並更新全域狀態。
+  - `ai_detector.py`（選用）對影像做 YOLO 偵測與註解，並回傳控制建議。
+- **瀏覽器前端**：
+  - 透過 MJPEG `/video` route 取得影像，Socket.IO 取得日誌/距離，並發送控制指令給 Flask。
+- **車體控制 (ESP8266 / Wi-Fi Bridge)**：
+  - 主要走 `http://<car-ip>/cmd?act=<...>`，無法聯通時 Flask 會回退序列埠寫入。
+
+## 整體流程圖
+```mermaid
+graph LR
+    subgraph Firmware
+        A[ESP32-S3 CAM\n esp32_main.ino]
+    end
+    subgraph Backend
+        B[Serial Worker\nserial_worker.py]
+        C[Video Stream Thread\nweb_server.py]
+        D[AI Detector (opt)\nai_detector.py]
+        E[Flask + Socket.IO\nweb_server.py]
+        F[SystemState\n(video_url, radar_dist...)]
+    end
+    subgraph Client
+        G[Web UI\n(browser)]
+    end
+    subgraph Vehicle
+        H[ESP8266/Car\nHTTP /cmd]
+    end
+
+    A -- "HTTP MJPEG /stream" --> C
+    A -- "Serial: DIST:x.x, IP logs" --> B
+
+    B -- "更新 video_url, radar_dist" --> F
+    C -- "Frame ->" --> D
+    D -- "Annotated frame" --> C
+    C -- "最新 Frame" --> F
+
+    F -- "Socket.IO logs/dist" --> G
+    G -- "控制指令" --> E
+    E -- "send_serial_command" --> H
+    E -- "Serial fallback" --> B
+    E -- "MJPEG /video" --> G
+```
+
+## 端到端事件序列
+1. **啟動**：ESP32 韌體初始化相機、Wi-Fi、超聲波並開始輸出距離與 IP 訊息。
+2. **設備偵測**：`serial_worker.py` 連線序列埠，解析 IP 後更新 `SystemState.video_url`；同時將 `DIST:` 數值寫入 `radar_dist`。
+3. **影像抓取**：`video_stream_thread()` 依 `video_url` 連線 ESP32 串流，成功後每幀放入 `frame_buffer`，若啟用 AI 則交由 `ObjectDetector.detect()` 產生註解與控制建議。
+4. **前端推送**：Flask 透過 `/video` 回傳 MJPEG，並以 Socket.IO 推送日誌、距離與串流狀態給瀏覽器。
+5. **控制回路**：使用者在瀏覽器下達指令；`send_serial_command()` 先嘗試透過 HTTP 轉送至車體 IP（含預設與偵測到的 bridge），若失敗則寫入序列埠作為備援。
+
+## 設計重點（改版時可沿用）
+- **狀態集中管理**：`SystemState` 持有串流 URL、距離、連線旗標，便於 UI 直接訂閱。
+- **雙通道控制**：Wi-Fi HTTP 為主，序列埠備援，降低網路不穩時的控制失效。
+- **可插拔 AI**：AI 偵測在串流執行緒內可選啟用，不影響基本串流與控制。
+- **容錯機制**：串流重試（3 次後延時）、序列埠掃描與 IP 緩存(`.last_bridge_host`) 讓系統自我恢復能力更強。
